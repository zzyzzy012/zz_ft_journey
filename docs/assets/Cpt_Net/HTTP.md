# HTTP

## HTTP 基本概念

### HTTP 是什么？

HTTP(*Hypertext Transfer Protocol*，超文本传输协议) 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

**请求和响应报文**

客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。

**(1) 请求报文结构**

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

```http
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

**(2) 响应报文结构**

- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个空行分隔首部和内容主体
- 最后是响应的内容主体

```http
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>
```

### 常见请求方法

(1) `GET`：获取资源。当前网络请求中，绝大部分使用的是 `GET` 方法。

(2) `HEAD`：获取报文首部。和 `GET` 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。

(3) `POST`：传输实体主体。`POST` 主要用来传输数据，而 `GET` 主要用来获取资源。

(4) `PUT`：上传文件。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

```http
PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16

<p>New File</p>
```

(5) `PATCH`：对资源进行部分修改。`PUT` 也可以用于修改资源，但是只能完全替代原始资源，`PATCH` 允许部分修改。

```http
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
```

(6) `DELETE`：删除文件。与 `PUT` 功能相反，并且同样不带验证机制。

```http
DELETE /file.html HTTP/1.1
```

(7) `OPTIONS`：查询指定的 URL 能够支持的方法。

HTTP 的 `OPTIONS` 方法用于获取目的资源所支持的通信选项，其用法有二种：

1. 检测服务器所支持的请求方法

![](.\HTTP\options.png)

2. CORS 中的预检请求

CORS 通过一种叫**预检请求**（*preflighted request*）的服务器验证机制，允许使用自定义头部、除 GET 、POST、HEAD（这三个也被称为**简单请求**） 之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个预检请求。这个请求使用 OPTIONS 方法发送并包含以下头部：

- `Origin`：与简单请求相同。
- `Access-Control-Request-Method`：请求希望使用的方法。
- `Access-Control-Request-Headers`：（可选）要使用的逗号分隔的自定义头部列表。

例如下面的请求报文(省略了一部分无关头部)：

```http
OPTIONS /user/user_info HTTP/1.1
Host: 47.106.202.255:8081
Connection: keep-alive
Accept: */*
Access-Control-Request-Method: GET
Access-Control-Request-Headers: authorization,loading
Origin: http://yuzzl.top
```

在这个请求发送之后，服务器确认是否允许，然后在响应头部附带以下内容：

- `Access-Control-Allow-Origin`：支持请求的路径。
- `Access-Control-Allow-Methods`：允许的方法（逗号分隔的列表）。
- `Access-Control-Allow-Headers`：服务器允许的头部（逗号分隔的列表）。
- `Access-Control-Max-Age`：缓存预检请求的秒数 (预检请求也是有缓存机制的)。

例如下面的响应报文：

```http
Access-Control-Allow-Credentials: true
Access-Control-Allow-Headers: authorization, loading
Access-Control-Allow-Methods: POST,GET,PUT,OPTIONS,DELETE
Access-Control-Allow-Origin: http://docs.yuzzl.top
Access-Control-Max-Age: 3600
```

(8) `CONNECT`：要求在与代理服务器通信时建立隧道。

使用 SSL（*Secure Sockets Layer*，安全套接层）和 TLS（*Transport Layer Security*，传输层安全）协议把通信内容加密后经网络隧道传输。

```http
CONNECT www.example.com:443 HTTP/1.1
```

[![img](https://camo.githubusercontent.com/17d12c4cff87bcfb59e0304cd2b1895d295c960a2a230ee3600f64d55bf1cbe9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64633030663730652d633563382d346432302d626166312d3264373030313461393765332e6a7067)](https://camo.githubusercontent.com/17d12c4cff87bcfb59e0304cd2b1895d295c960a2a230ee3600f64d55bf1cbe9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64633030663730652d633563382d346432302d626166312d3264373030313461393765332e6a7067)

(9) `TRACE`：追踪路径。服务器会将通信路径返回给客户端。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。

通常不会使用 `TRACE`，并且它容易受到 XST 攻击（*Cross-Site Tracing*，跨站追踪）。

### HTTP 常见的状态码有哪些？

![](.\HTTP\6-五大类HTTP状态码.png)

**1XX 信息**

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

**2XX 成功**

- **200 OK**
- **204 No Content** ：请求已经成功处理，但响应头没有 body 数据。一般只在客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content** ：是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

**3XX 重定向**

- **301 Moved Permanently**：永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 
- **302 Found**：临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 

> 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
>
> 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。

- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- **304 Not Modified** ：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

**4XX 客户端错误**

- **400 Bad Request** ：请求报文中存在语法错误。
- **401 Unauthorized** ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被拒绝。
- **404 Not Found**

**5XX 服务器错误**

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### HTTP 常见字段有哪些？

(1) *Host* 字段：客户端发送请求时，用来指定服务器的域名。

```http
Host: www.A.com
```

(2) *Content-Length* 字段：服务器在返回数据时，会有 *Content-Length* 字段，表明本次回应的数据长度。

HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个粘包问题。

解决粘包问题：

- HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界
- 通过 *Content-Length* 字段作为 HTTP body 的边界

(3) *Connection* 字段：最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。

HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 *Connection* 首部字段的值为 *Keep-Alive*。

```http
Connection: Keep-Alive
```

开启了 HTTP *Keep-Alive* 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。

(4) *Content-Type* 字段：用于服务器回应时，告诉客户端，本次数据是什么格式。

```http
Content-Type: text/html; Charset=utf-8  // 发送的是网页，而且编码是UTF-8
```

 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。 

```http
Accept: */*  // 客户端声明自己可以接受任何格式的数据
```

(5) *Content-Encoding* 字段：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。

```http
Content-Encoding: gzip  // 服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压
```

客户端在请求时，用 *Accept-Encoding* 字段说明自己可以接受哪些压缩方法。 

```http
Accept-Encoding: gzip, deflate
```

#### HTTP 首部

有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。

**(1) 通用首部字段**

| 首部字段名          | 说明                                       |
| ------------------- | ------------------------------------------ |
| *Cache-Control*     | 控制缓存的行为                             |
| *Connection*        | 控制不再转发给代理的首部字段、管理持久连接 |
| *Date*              | 创建报文的日期时间                         |
| *Pragma*            | 报文指令                                   |
| *Trailer*           | 报文末端的首部一览                         |
| *Transfer-Encoding* | 指定报文主体的传输编码方式                 |
| *Upgrade*           | 升级为其他协议                             |
| *Via*               | 代理服务器的相关信息                       |
| Warning             | 错误通知                                   |

**(2) 请求首部字段**

| 首部字段名            | 说明                                            |
| --------------------- | ----------------------------------------------- |
| *Accept*              | 用户代理可处理的媒体类型                        |
| *Accept-Charset*      | 优先的字符集                                    |
| *Accept-Encoding*     | 优先的内容编码                                  |
| *Accept-Language*     | 优先的语言（自然语言）                          |
| *Authorization*       | Web 认证信息                                    |
| *Expect*              | 期待服务器的特定行为                            |
| *From*                | 用户的电子邮箱地址                              |
| *Host*                | 请求资源所在服务器                              |
| *If-Match*            | 比较实体标记（ETag）                            |
| *If-Modified-Since*   | 比较资源的更新时间                              |
| *If-None-Match*       | 比较实体标记（与 If-Match 相反）                |
| *If-Range*            | 资源未更新时发送实体 Byte 的范围请求            |
| *If-Unmodified-Since* | 比较资源的更新时间（与 If-Modified-Since 相反） |
| *Max-Forwards*        | 最大传输逐跳数                                  |
| *Proxy-Authorization* | 代理服务器要求客户端的认证信息                  |
| *Range*               | 实体的字节范围请求                              |
| *Referer*             | 对请求中 URI 的原始获取方                       |
| *TE*                  | 传输编码的优先级                                |
| *User-Agent*          | HTTP 客户端程序的信息                           |

**(3) 响应首部字段**

| 首部字段名           | 说明                         |
| -------------------- | ---------------------------- |
| *Accept-Ranges*      | 是否接受字节范围请求         |
| *Age*                | 推算资源创建经过时间         |
| *ETag*               | 资源的匹配信息               |
| *Location*           | 令客户端重定向至指定 URI     |
| *Proxy-Authenticate* | 代理服务器对客户端的认证信息 |
| *Retry-After*        | 对再次发起请求的时机要求     |
| *Server*             | HTTP 服务器的安装信息        |
| *Vary*               | 代理服务器缓存的管理信息     |
| *WWW-Authenticate*   | 服务器对客户端的认证信息     |

**(4) 实体首部字段**

| 首部字段名         | 说明                   |
| ------------------ | ---------------------- |
| *Allow*            | 资源可支持的 HTTP 方法 |
| *Content-Encoding* | 实体主体适用的编码方式 |
| *Content-Language* | 实体主体的自然语言     |
| *Content-Length*   | 实体主体的大小         |
| *Content-Location* | 替代对应资源的 URI     |
| *Content-MD5*      | 实体主体的报文摘要     |
| *Content-Range*    | 实体主体的位置范围     |
| *Content-Type*     | 实体主体的媒体类型     |
| *Expires*          | 实体主体过期的日期时间 |
| *Last-Modified*    | 资源的最后修改日期时间 |

## GET 与 POST

### GET 和 POST 有什么区别？

根据 RFC 规范，**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。

**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

> RFC（*Request for Comments*）规范 HTTP 方法的标准文档

### GET 和 POST 方法都是安全和幂等的吗？

- 安全：请求方法不会破坏服务器上的资源
- 幂等：多次执行相同的操作，结果都是相同的

如果从 RFC 规范定义的语义来看：

- GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
- POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。


- **GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。**
- **POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。**

实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。

**① 安全**

- 安全的方法除了 GET 之外还有：HEAD、OPTIONS。
- 不安全的方法除了 POST 之外还有 PUT、DELETE。

**② 幂等性**

- 所有的安全方法也都是幂等的。
- 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

**③ 可缓存**

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：`200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501`。
- 响应报文的 *Cache-Control* 首部字段没有指定不进行缓存。

## HTTP 缓存技术

### 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

```http
Status Code: 200 (from disk cache)  // 强制缓存
```

强缓存是利用下面这两个 HTTP 响应头部（*Response Header*）字段实现的，它们都用来表示资源在客户端缓存的有效期：

- *Cache-Control*：是一个相对时间
- *Expires*：是一个绝对时间

如果 HTTP 响应头部同时有 *Cache-Control* 和 *Expires* 字段的话，***Cache-Control* 的优先级高于 *Expires***。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。

具体的实现流程如下： 

1. 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 *Cache-Control*，*Cache-Control* 中设置了过期时间大小；
2. 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 *Cache-Control* 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
3. 服务器再次收到请求后，会再次更新 Response 头部的 *Cache-Control*。

### 协商缓存

协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。

![](.\HTTP\缓存etag.webp)

 协商缓存可以基于两种头部来实现。

1. 请求头部中的 *If-Modified-Since* 字段与响应头部中的 *Last-Modified* 字段
   - 响应头部中的 *Last-Modified*：标示这个响应资源的最后修改时间；
   - 请求头部中的 *If-Modified-Since*：当资源过期了，发现响应头中具有 *Last-Modified* 声明，则再次发起请求的时候带上上一次的 *Last-Modified* 的时间，服务器收到请求后发现有 *If-Modified-Since* 则与被请求资源的最后修改时间 *Last-Modified* 进行对比：
     - 如果最后修改时间较新 / 大（如果资源的 *Last-Modified* 时间晚于 *If-Modified-Since*），说明资源又被改过，则返回最新资源，HTTP 200 OK；
     - 如果最后修改时间较旧 / 小（资源的 *Last-Modified* 时间等于或早于 *If-Modified-Since*），说明资源无新修改，响应 HTTP 304 走缓存。
2. 请求头部中的 *If-None-Match* 字段与响应头部中的 ETag 字段
   - 响应头部中 Etag：唯一标识响应资源；
   - 请求头部中的 *If-None-Match*：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 *If-None-Match* 值设置为 Etag 的值。
     - 服务器收到请求后进行比对，如果资源没有变化返回 304；
     - 如果资源变化了返回 200。

> 可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 *Last-Modified* 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 *Last-Modified* 字段信息给服务端，这时 **Etag 的优先级更高**。

- 服务端先会判断 Etag 是否变化了：
  - 如果 Etag 有变化，不用再判断 *Last-Modified* 了；
  - 如果 Etag 没有变化，然后再看 *Last-Modified*。 

注意，**协商缓存这两个字段都需要配合强制缓存中 *Cache-Control* 字段来使用**，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。 

![](.\HTTP\http缓存.webp)

当使用 ETag 字段实现的协商缓存的过程：

1. 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
2. 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 
   - 如果没有过期，则直接使用本地缓存；
   - 如果缓存过期了，会在 Request 头部加上 *If-None-Match* 字段，该字段的值就是 ETag 唯一标识；
3. 服务器再次收到请求后，会根据请求中的 *If-None-Match* 值与当前请求的资源生成的唯一标识进行比较：
   - 如果值相等，则返回 304 Not Modified，不会返回资源；
   - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
4. 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

### Cookie

HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来保存状态信息。HTTP Cookie（简称 Cookie）是一种小型文本文件，Cookie 是服务器发送到浏览器的小数据片段，浏览器将其保存并在后续请求中回传给同一服务器。

**(1) 用途**

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

**(2) 创建过程**

服务器发送的响应报文包含 *Set-Cookie* 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。

```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

**(3) 分类**

- 会话期 Cookie：浏览器关闭之后它会被自动删除，仅在会话期内有效。
- 持久性 Cookie：指定过期时间（Expires）或有效期（*max-age*）之后就成为了持久性的 Cookie。

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

**(4) 作用域**

① `Domain` 指定 Cookie 所属域名，默认是当前域名。

- 如果指定了 `Domain`，则一般包含子域名。

> 如果设置 `Domain=mozilla.org`，则 Cookie 也包含在子域名中（如 `developer.mozilla.org`）。

② `Path` 限制 Cookie 的生效路径（该 URL 路径必须存在于请求 URL 中）。以字符 `%x2F ("/") `作为路径分隔符，子路径也会被匹配。

> 如设置 `Path=/docs`，则以下地址都会匹配：`/docs`、`/docs/Web/`、`/docs/Web/HTTP`。

**(5) JS 创建 Cookie**

浏览器通过 `document.cookie` 属性可创建新的 Cookie，也可通过该属性访问非 `HttpOnly` 标记的 Cookie。

```js
document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
```

`HttpOnly`：标记为 `HttpOnly` 的 Cookie 不能被 JavaScript 脚本调用。

跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `document.cookie` API 窃取用户的 Cookie 信息，因此使用 `HttpOnly` 标记可以在一定程度上避免 XSS 攻击。

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

**(6) `Secure`**

标记为 `Secure` 的 Cookie 只能被 **HTTPS 协议**加密过的请求发送给服务端。但即便设置了 `Secure` 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，`Secure` 标记也无法提供确实的安全保障。

**(7) Session**

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 **Session 存储在服务器端**。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中。

**浏览器禁用 Cookie**：

1. 无法使用 Cookie 来保存用户信息，只能使用 Session。
2. 不能再将 *Session ID* 存放到 Cookie 中，而是使用 URL 重写技术，将 *Session ID* 作为 URL 的参数进行传递。

**Cookie 与 Session 选择**：

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据。
- Cookie 存储在浏览器中，容易被恶意查看。
- 如果用户所有的信息都存储在 Session 中，开销大。

## HTTP 特性

### HTTP/1.1 的优点有哪些？

HTTP 最突出的优点是「**简单、灵活和易于扩展、应用广泛和跨平台**」。

(1) 简单

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，易于理解，降低了学习和使用的门槛。 

(2) 灵活和易于扩展

- HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
- 同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化，比如：
  - HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；
  - HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。 

### HTTP/1.1 的缺点有哪些？

**无状态、明文传输、不安全**

(1) 无状态双刃剑

- 无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。
- 无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。 

对于无状态的问题，解法方案之一 Cookie 技术。 

Cookie 通过在**请求和响应报文中写入 Cookie 信息来控制客户端的状态**。 

> 相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了， 

(2) 明文传输双刃剑

- 在传输过程中的信息，是可方便阅读的。
- HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。

(3) 不安全

- 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
- 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
- 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层。

### HTTP/1.1 的性能如何？

HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。

**(1) 长连接**

- 早期 HTTP1.0 短连接：每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

- HTTP/1.1 长连接 / 持久连接：减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

  - 持久连接的特点：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。


  - 如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接。

![](.\HTTP\HTTP1.0短连接与HTTP1.1长连接.webp)

**(2) 管道网络传输**

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 

**但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。**如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「**队头堵塞**」。 

**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。**

![](.\HTTP\HTTP1.1管道网络传输.webp)

**(3) 队头阻塞**

**请求 - 应答的模式**会造成 HTTP 的性能问题。为什么呢？

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」，好比上班的路上塞车。

![](.\HTTP\HTTP1.1队头阻塞.webp)

## HTTP 与 HTTPS

### HTTP 与 HTTPS 有哪些区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. 两者的默认端口不一样，HTTP 默认端口号是 `80`，HTTPS 默认端口号是 `443`。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### HTTPS 解决了 HTTP 的哪些问题？

HTTP 风险：窃听风险、篡改风险、冒充风险

HTTPS 解决上述风险：信息加密、校验机制、身份证书

![](.\HTTP\HTTPS与HTTP.webp)

HTTPS 是如何解决上面的三个风险的？

1. **混合加密**实现信息的机密性，解决了窃听风险。
2. **摘要算法**实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改风险。
3. 将服务器公钥放入到数字证书中，解决了冒充风险。

**(1) 混合加密**

HTTPS 采用的是**对称加密和非对称加密结合的「混合加密」方式**：

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

![](.\HTTP\HTTPS混合加密.webp)

采用「混合加密」的方式的原因：

- 对称加密（*Symmetric-Key Encryption*）：只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。

- 非对称加密 / 公开密钥加密（*Public-Key Encryption*）：使用两个密钥 — 公钥和私钥。公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

  > 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
  >
  > 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

**(2) 摘要算法 + 数字签名**

为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。

对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

在计算机里会用**摘要算法（哈希函数）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。**

![](.\HTTP\HTTPS摘要算法.webp)

通过哈希算法可以确保内容不会被篡改，但是**并不能保证「内容 + 哈希值」不会被中间人替换**，因为这里**缺少对客户端收到的消息是否来源于服务端的证明**。

那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥：

- 一个是公钥，这个是可以公开给所有人的；
- 一个是私钥，这个必须由本人管理，不可泄露。

这两个密钥可以**双向加解密**的：

- **公钥加密，私钥解密**。这个目的是为了保证**内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了保证**消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。 

一般我们**不会用非对称加密来加密实际的传输内容**，因为非对称加密的计算比较耗费性能的。

**数字签名算法**：私钥加密对内容的哈希值加密，来确认消息的身份。

把这个 hash 值加密后做为一个签名和信息一起发出去。接收方在收到信息后，会重新计算信息的 hash 值，并和信息所附带的 hash 值（解密后）进行对比，如果一致，就说明信息的内容没有被修改过。

私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

![](.\HTTP\数字签名.webp)

**(3) 数字证书**

CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。 

**(1) 颁发过程**

1. 用户首先**产生自己的密钥对**，并将公共密钥及部分个人身份信息传送给认证中心。
2. 认证中心将发给用户一个**数字证书**，该证书内包含**用户的个人信息和他的公钥信息**，同时还附有认证中心的**签名信息**(根证书私钥签名)。

**(2) 如何验证**

浏览器/操作系统默认**内置了 CA 的根证书。根证书包含了这个 CA 的公钥。**

如果:

- 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书
- 如果伪造的证书颁发的机构是确实存在的，于是根据 CA 名，找到对应内置的 CA 根证书、CA 的公钥。用 CA 的公钥，对伪造的证书的摘要进行解密，发现解不了, 认为是危险证书。
- 对于篡改的证书，使用 CA 的公钥对数字签名进行解密得到摘要 A，然后再根据签名的 Hash 算法计算出证书的摘要 B，对比 A 与 B，若相等则正常，若不相等则是被篡改过的。
- 证书可在其过期前被吊销。较新的浏览器如 Chrome、Firefox、Opera 和 Internet Explorer 都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过 OCSP 发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。

![](.\HTTP\数字证书工作流程.webp)

### HTTPS 是如何建立连接的？其间交互了什么？

SSL/TLS 协议基本流程：

1. 客户端向服务器索要并验证服务器的公钥。
2. 双方协商生产「会话秘钥」。
3. 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 **TLS 握手阶段**。**TLS 的「握手阶段」涉及四次通信**，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：**RSA 算法和 ECDHE 算法**。

基于 RSA 算法的 TLS 握手过程：

(1) Client Hello

由客户端向服务器发起加密通信请求。客户端主要向服务器发送以下信息： 

1. 客户端支持的 TLS 协议版本。
2. 客户端生产的随机数（*Client Random*），后面用于生成「会话秘钥」条件之一。
3. 客户端支持的密码套件列表。

(2) Sever Hello

服务器收到客户端请求后，向客户端发出响应。服务器回应的内容有如下内容：

1. 确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。
2. 服务器生产的随机数（*Server Random*）。
3. 确认的密码套件列表。
4. 服务器的数字证书。

(3) 客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息： 

1. 一个随机数（*pre-master key*）。该随机数会被服务器公钥加密。
2. 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

服务器和客户端有了这三个随机数（*Client Random、Server Random、pre-master key*），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

(4) 服务器的最后回应

服务器收到客户端的第三个随机数（*pre-master key*）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。 然后，向客户端发送最后的信息：

1. 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

> **密钥交换**
>
> - 客户端生成一个“预主密钥（pre-master key）”，用服务器公钥加密后发送给服务器（或使用 ECDHE 等方式协商密钥）
>
> **生成对称密钥**
>
> - 双方通过 client random、server random 和 pre-master key，共同生成对称加密所用的 session key（会话密钥）
>
> **Finished 消息**
>
> - 双方用协商好的加密方式发送“Finished”消息，表示握手结束
> - 后续通信均使用对称加密进行，确保安全和高效

![](.\HTTP\HTTPS工作流程—基于RSA算法.webp)

客户端校验数字证书的流程：

![](.\HTTP\证书的校验.webp)

证书的验证过程中还存在一个**证书信任链**的问题，因为我们向 CA 申请的证书一般不是**根证书**签发的，而是由**中间证书**签发的。这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。

## HTTP/1.1、HTTP/2、HTTP/3 演变

### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 长连接
- 支持管道（pipeline）网络传输

HTTP/1.1 的性能瓶颈：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。
- 只能压缩 Body 的部分； 发送冗长的首部。
- 每次互相发送相同的首部造成的浪费较多；
- 没有请求优先级控制；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 请求只能从客户端开始，服务器只能被动响应。

### HTTP/2 做了什么优化？

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

![](.\HTTP\HTTP2.png)

HTTP/2 相比 HTTP/1.1 性能上的改进：

1. 头部压缩
2. 二进制格式
3. 并发传输
4. 服务器主动推送资源

**(1) 头部压缩**

HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，协议会帮你消除重复的部分。

通过 **HPACK 算法**：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

**(2) 二进制格式**

HTTP/2 不再像 HTTP/1.1 里的**纯文本形式的报文**，而是全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为**帧（frame）**：**头信息帧（*Headers Frame*）和数据帧（*Data Frame*）**。

对人不友好但对计算机友好，这样收到报文后无需再将报文转化为二进制，而是**直接解析二进制报文，增加数据传输效率。**

**(3) 并发传输**

HTTP/2 引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。

1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。

针对不同的 HTTP 请求用独一无二的 *Stream ID* 来区分，接收端可以通过 *Stream ID* 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。

![](.\HTTP\stream.png)

**(4) 服务器推送**

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，**服务端不再是被动地响应，可以主动向客户端发送消息。** 

客户端和服务器双方都可以建立 Stream， *Stream ID* 也是有区别的：

- 客户端建立的 Stream 必须是**奇数号**；
- 服务器建立的 Stream 必须是**偶数号**。

HTTP/2 有什么缺陷？

HTTP/2 还是存在**队头阻塞**的问题，只不过问题**不是在 HTTP 这一层面，而是在 TCP 这一层**。

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

### HTTP/3 做了哪些优化？

- HTTP/1.1 中的管道（ pipeline）虽然**解决了请求的队头阻塞，但是没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 **HTTP 层队头阻塞**。
- HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 **TCP 层队头阻塞**。

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**！

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。

UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。

QUIC 有以下 3 个特点：

1. 无队头阻塞
2. 更快的连接建立
3. 连接迁移

![](.\HTTP\HTTP3.webp)

**(1) 无队头阻塞**

QUIC 协议也有类似 HTTP/2 **Stream 与多路复用**的概念，也是可以在同一条连接上并发传输多个 Stream，**Stream 可以认为就是一条 HTTP 请求**。

QUIC 有自己的一套机制可以保证传输的可靠性的。**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。**

- 这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。
- QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。

**(2) 更快的连接建立**

对于 HTTP/1 和 HTTP/2 协议，**TCP 和 TLS 是分层的**，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，**需要分批次来握手，先 TCP 握手，再 TLS 握手**。

HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 **1 RTT**，握手的目的是为**确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的**。

RTT(*Round-Trip Time*，往返时间) 从你发送数据包 → 对方收到 → 马上回复 → 你收到回复，这整个过程的耗时。通常用于描述网络延迟。

**HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的记录，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商**。

甚至，在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。

![](.\HTTP\HTTP3交互次数.webp)

**(3) 连接迁移**

基于 TCP 传输协议的 HTTP 协议，由于是通过**四元组（源 IP、源端口、目的 IP、目的端口）**确定一条 TCP 连接。 

那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。**而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。

而 QUIC 协议没有用四元组的方式来绑定连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以无缝地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。

**QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。**

QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP 包，然后被丢弃。

## CDN

**(1) 概念**

**CDN (*Content Delivery Network*，内容分发网络)** 构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的**负载均衡、内容分发、调度**等功能模块，使**用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率**。

简单来讲，CDN 就是**根据用户位置分配最近的资源**。

于是，用户在上网的时候不用直接访问源站，而是访问离他最近的一个 CDN 节点，术语叫**边缘节点**，其实就是**缓存了源站内容的代理服务器**。

**(2) 原理分析**

在没有应用 CDN 时，我们使用域名访问某一个站点时的路径为：

用户提交域名 → 浏览器对域名进行解释 → DNS 解析得到目的主机的IP地址 → 根据IP地址访问发出请求 → 得到请求数据并回复

应用 CDN 后，DNS 返回的不再是 IP 地址，而是一个 **CNAME(*Canonical Name*，别名记录)** ，**指向 CDN 的全局负载均衡**。

CNAME 实际上在域名解析的过程中承担了**中间人（代理）的角色**，这是 CDN 实现的关键。

**① 负载均衡系统**

本地 DNS 会向**负载均衡系统**发送请求，进入到 **CDN 的全局负载均衡系统**进行智能调度：

- 看用户的 IP 地址，查表得知地理位置，找**相对最近的边缘节点**
- 看用户所在的运营商网络，找**相同网络的边缘节点**
- 检查边缘节点的负载情况，找**负载较轻的节点**
- 其他，比如节点的健康状况、服务能力、带宽、响应时间等

结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问 **CDN 的缓存代理**。

**② 缓存代理**

缓存系统是 CDN 的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源。

衡量 CDN 服务质量的指标：

1. **命中率**：用户访问的资源恰好在缓存系统里，可以直接返回给用户，**命中次数与所有访问次数之比**。
2. **回源率**：缓存里没有，必须用代理的方式回源站取，**回源次数与所有访问次数之比**。

缓存系统也分层次：

1. **一级缓存节点**，配置高一些，直连源站。
2. **二级缓存节点**，配置低一些，直连用户。

回源的时候二级缓存只找一级缓存，**一级缓存没有才回源站**，可以有效地减少真正的回源。

现在的商业 CDN 命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上。

通过 CDN 的负载均衡系统，智能调度边缘节点提供服务，相当于 CDN 服务的大脑，而缓存系统相当于 CDN 的心脏，缓存命中直接返回给用户，否则回源。

## 代理

代理服务器本身**不生产内容**，它作为一个**中继转发上下游的请求**。

**(1) 正向代理**

- 1 由于某些原因（例如防火墙）无法访问 3
- 此时我们通过 2（正向代理）访问 3
- 正向代理做到了**隐藏客户端**的身份
- 一些**抓包工具**的原理就是利用了正向代理服务

![](.\HTTP\正向代理.png)

**(2) 反向代理**

- 1 访问 2，2 将 1 的请求转发给 3
- 反向代理可以用来**隐藏服务器的身份、实现负载均衡**

![](.\HTTP\反向代理.png)

## WebSocket

**(1) 概念**

**`WebSocket` 本质上是计算机网络应用层的协议（位于 `OSI` 模型的应用层）。可在单个 TCP 连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅**。

**客户端和服务器只需要完成一次握手**，两者之间就可以创建持久性的连接，并进行双向数据传输。

在 `WebSocket` 出现之前，开发实时 `web` 应用的方式为**轮询**，不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果**轮询的频率比较高**，那么就可以**近似地实现实时通信的效果**。

轮询的缺点：反复发送无效查询请求**耗费了大量的带宽和 CPU 资源**。

`WebSocket` 的应用场景：

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新

**(2) 特点**

**① 全双工**

通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。

- 例如指 A→B 的同时 B→A ，是瞬时同步的

**② 二进制帧**

- 采用了**二进制帧结构**，语法、语义与 HTTP 完全不兼容，相比 `HTTP/2`，`WebSocket ` 更侧重于实时通信，而 `HTTP/2` 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。

- 不像 `HTTP/2` 那样定义流，也就不存在多路复用、优先级等特性。

- 自身就是全双工，也不需要服务器推送。

**`WebSocket` 与 HTTP 的区别**

- 都是一样基于 TCP 的，都是可靠性传输协议。都是应用层协议。
- `WebSocket` 在建立握手时，数据是通过 HTTP 传输的。但是建立之后，在真正传输时候是不需要 HTTP 协议的。

**③ 协议名**

引入 `ws` 和 `wss` 分别代表明文和密文的 `WebSocket` 协议，且默认端口使用 `80` 或 `443`，几乎与 HTTP 一致。

```
ws://www.chrono.com
ws://www.chrono.com:8080/srv
wss://www.chrono.com:445/im?user_id=xxx
```

**④ 握手**

`WebSocket ` 也要有一个握手过程，才能正式收发数据。

**`WebSocket ` 建立连接过程**：

1. 客户端发起 HTTP 请求，经过 3次 握手后，建立起 TCP 连接；HTTP 请求里存放 `WebSocket` 支持的版本号等信息，如：`Upgrade、Connection、WebSocket-Version` 等；
2. 服务器收到客户端的握手请求后，同样采用 `HTTP` 协议回馈数据；
3. 客户端收到连接成功的消息后，开始借助于 TCP 传输信道进行全双工通信。

**客户端发送数据格式如下**：

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

- `Connection`：必须设置 `Upgrade`，表示客户端希望连接升级。
- `Upgrade`：必须设置 `Websocket`，表示希望升级到 `Websocket` 协议。
- `Sec-WebSocket-Key`：客户端发送的一个 `base64` 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的 `Sec-WebSocket-Accept` 应答，否则客户端会抛出错误，并关闭连接。
- `Sec-WebSocket-Protocol`：表示最终使用的协议。
- `Sec-WebSocket-Version`：表示支持的 `Websocket` 版本。

**服务端返回的数据格式**：

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat
```

- `HTTP/1.1 101 Switching Protocols`：表示服务端接受 `WebSocket` 协议的客户端连接
- `Sec-WebSocket-Accep`：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里 `Sec-WebSocket-Key` 的值，加上一个专用的 `UUID`，再计算摘要。

**(3) 优点**

- 较少的控制开销：数据包头部协议较小，不同于 HTTP 每次请求需要携带完整的头部。
- 更强的实时性：相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。
- 保持创连接状态：创建通信后，可省略状态信息，不同于 HTTP 每次请求需要携带身份验证。
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容。
- 支持扩展：用户可以扩展 `WebSocket` 协议、实现部分自定义的子协议。
- 更好的压缩效果：`WebSocket` 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。