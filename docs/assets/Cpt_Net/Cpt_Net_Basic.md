# 计算机网络

[TOC]

## 计算机网络体系结构

![](.\Basic\OSI和五层协议和TCP.png)

**(1) 五层协议**

1. **应用层** ：为**特定应用程序**提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为**报文**。
2. **传输层** ：为**主机中的进程**提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。
   - 运输层包括两种协议：
   - **传输控制协议 TCP**，提供面向连接、可靠的数据传输服务，数据单位为**报文段**；
   - **用户数据报协议 UDP**，提供无连接、尽最大努力的数据传输服务，数据单位为**用户数据报**。
   - TCP 主要提供完整性服务，UDP 主要提供及时性服务。
3. **网络层** ：为**主机**提供数据传输服务。网络层把传输层传递下来的**报文段或者用户数据报封装成分组**。
4. **数据链路层** ：主机之间可以有很多链路，链路层协议就是**为同一链路的主机**提供数据传输服务。数据链路层把网络层传下来的**分组封装成帧**。
5. **物理层** ：考虑的是怎样**在传输媒体上传输数据比特流**，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

**(2) OSI**

- **表示层** ：数据压缩、加密以及数据描述，这使得**应用程序不必关心在各台主机中数据内部格式不同的问题**。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

**(3) TCP/IP**

它只有四层，相当于五层协议中**数据链路层和物理层合并为网络接口层**。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![](.\Basic\TCP和IP.png)

**(4) 数据在各层之间的传递过程**

在向下的过程中，需要**添加下层协议所需要的首部或者尾部**，而在向上的过程中**不断拆开首部和尾部**。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为**进程或者应用程序**提供服务，因此也就不需要**传输层和应用层**。

## TCP/IP网络模型

设备通信：协商一套通用的网络协议，这个网络协议是分层的，每一层都有各自的作用和职责，主要根据 **TCP/IP 网络模型**。

**(1) 应用层**

**应用层（*Application Layer*）**：客户端接触到的，只专注于为用户提供应用功能，比如 HTTP、DNS 协议。应用层不关心数据如何传输，会将数据传递给传输层。

**DNS 域名系统**：是一个分布式数据库，提供了**主机名和 IP 地址**之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

简单来说：DNS 是用域名来定位真正的 IP 地址，是一个迭代查询和递归查询的过程。

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

**(2) 传输层**

**传输层（*Transport Layer*）**：应用层的数据包传给传输层，传输层是为应用层提供网络支持的。*实际不负责将数据从一个设备传递给另一个设备。*

在传输层会有两个传输协议，分别是 **TCP** 和 **UDP**：

1. **传输控制协议 TCP（*Transmission Control Protocol*）**，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比  UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。

2. **UDP** 只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。*UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以。*


应用层需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 **MSS（TCP 最大报文段长度）** ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 **TCP 段（*TCP Segment*）**。

![](.\Basic\TCP段.webp)

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于**浏览器（客户端）中的每个标签栏都是一个独立的进程**，操作系统会为这些进程分配临时的**端口号**。

传输层的报文中会携带端口号，接收方可以识别出该报文是发送给哪个应用。

**常用端口**

| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |
| ---------------- | ---------- | ------- | ---------- | --------------------------- |
| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |
| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |
| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议     | TELNET     | 23      | TCP        |                             |
| 超文本传送协议   | HTTP       | 80      | TCP        |                             |
| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |
| 邮件读取协议     | POP3       | 110     | TCP        |                             |
| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |

**(3) 网络层**

**网络层（*Internet Layer*）**：实现应用到应用的通信。传输层只是作为数据传输的媒介，专注于服务好应用层。

网络层最常使用的是 **IP 协议（*Internet Protocol*）**，IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就**会再次进行分片**，得到一个即将发送到网络的 IP 报文。

![](.\Basic\IP协议.webp)

网络层需要有区分设备的编号。将 IP 地址分成两种意义：

- **网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- **主机号**，负责标识同一「子网」下的不同主机；

需要配合**子网掩码**才能算出 IP 地址 的网络号和主机号。在寻址中，先找到网络号（相同的子网）再找主机号。

路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。

![](.\Basic\路由寻址.webp)

**(4) 网络接口层**

**网络接口层（*Link Layer*）**：在 IP 头部的前面加上 **MAC 头部**，并封装成**数据帧（*Data frame*）**发送到网络上。

IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

**以太网**：是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，都是以太网的组成部分。

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 **MAC 头部**就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，可以通过 **ARP 协议**获取对方的 MAC 地址。

**网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。**

![](.\Basic\tcpip参考模型.drawio.webp)

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

![](.\Basic\封装.webp)

## 键入网址到网页显示，期间发生了什么？

### 1) 孤独小弟 — HTTP

(1) 浏览器做的第一步工作是**解析 URL**

生成发送给 web 服务器的请求信息。

URL 各元素代表什么：图中的 URL 实际是请求服务器里的文件资源，如果路径名省略，就代表访问**根目录下事先设置的默认文件**，也就是 `/index.html` 或者 `/default.html`。

![](.\Basic\URL解析.webp)

**(2) 生成HTTP请求信息。**

![](.\Basic\HTTP请求信息.webp)

### 2) 真实地址查询 — DNS

解析完 URL 并生成 HTTP 报文后，将消息发送给 web 服务器之前，需要**查询服务器域名对应的 IP 地址**。

**DNS服务器**：专门存储 web 服务器域名与 IP 的对应关系。

**(1) 域名层级关系**

用句号 `.` 分隔，域名越往右层级越高。域名实际上还有一个点 `.` 表示根域名。根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。

域名层级关系类似树状结构，`.` 根域 在最顶层，它的下一层 顶级域，再下面 权威域。

如 `www.server.com.`

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

![](.\Basic\域名层级结构.webp)

**(2) 域名解析工作流程**

不是每次域名解析都需要经过如下图的很多流程，因为有**缓存**。

**浏览器**会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统；**操作系统**也会去看自己的缓存，如果有，就直接返回，如果没有，再去 **hosts 文件**看，也没有，才会去问 **本地 DNS 服务器**。

![](.\Basic\DNS域名解析.webp)

### 3) 指南好帮手 — 协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。

协议栈的上半部分有两块，分别是负责收发数据的 **TCP 和 UDP 协议**，这两个传输协议会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 **IP 协议** 控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

IP 中还包括 ICMP 协议（*Internet Control Message Protocol*，互联网控制消息协议）和 ARP 协议（*Address Resolution Protocol*，地址解析协议）。

- **ICMP** 用于告知网络包传送过程中产生的错误以及各种控制信息。
- **ARP** 用于根据 IP 地址查询相应的以太网 MAC 地址。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

![](.\Basic\协议栈.webp)

### 4)可靠传输 — TCP

HTTP 是基于 TCP 协议传输的。

**(1) TCP包头格式**

1. **源端口号**和**目标端口号**：数据应该发给哪个应用(进程)。
2. **序号**：为了解决**包乱序**的问题。
3. **确认号**：确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，为了解决**丢包**的问题。
4. **状态位**：TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
   - `SYN` 是发起一个连接
   - `ACK` 回复
   - `RST` 是重新连接
   - `FIN` 是结束连接
5. **窗口大小**：TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，*别发送的太快，撑死我，也别发的太慢，饿死我。*
6. TCP还会做**拥塞控制**，控制发送的速度。

![](.\Basic\TCP报文头部格式.webp)

**(2) TCP 传输数据之前，要先三次握手建立连接**

在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为**三次握手**。 

这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。 

1. 客户端和服务端都处于 `CLOSED` 状态。
2. 先是服务端主动监听某个端口，处于 `LISTEN` 状态。
3. 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。 
4. 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。 
5. 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。 

**三次握手目的是保证双方都有发送和接收的能力。**

![](.\Basic\TCP三次握手.drawio.webp)

**(3) TCP分割数据**

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。 

![](.\Basic\TCP分割数据1.webp)

- `MTU`（*Maximum Transmission Unit*，最大传输单元）：一个网络包的最大长度，包括包含 **IP头部、TCP头部和数据 payload**。
  - 以太网中一般为 `1500` 字节。 
  - 如果数据包超过 MTU，会触发 IP 分片（*fragmentation*）。
- `MSS`（*Maximum Segment Size*，最大段大小）：**除去 IP 和 TCP 头部之后**，一个网络包所能容纳的 `TCP` 数据的最大长度。 

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![](.\Basic\TCP分割数据2.webp)

**(4) TCP报文生成**

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

 在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。 

网络包的报文格式：

![](.\Basic\TCP报文生成.webp)

### 5) 远程定位 — IP

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。 

- IP地址是分配给网络中主机的唯一标识。
- MAC 地址（*Media Access Control Address*，介质访问控制地址）是数据链路层（Layer 2）的物理地址，唯一标识网络设备的网卡。
- 主机地址：泛指**网络中任何设备**的 IP 地址，包括**服务器、客户端、路由器**等。任何参与网络通信的设备都可以称为主机。
- 服务器地址：特定类型主机（服务器）的 IP 地址。

**(1) IP包头格式**

- 首部长度：表示 IP 包头的长度。
- 服务类型（*Type of Service*，TOS）：定义数据包的服务质量（QoS）
- 总长度：表示整个 IP 数据包（包括头部和数据部分）的总字节数。
- 标识：唯一标识一个 IP 数据包，用于分片和重组。
- 标志：控制分片行为：
  - 第 1 位：保留，恒为 0。
  - 第 2 位：DF（*Don’t Fragment*），置 1 表示禁止分片。
  - 第 3 位：MF（*More Fragments*），置 1 表示还有更多分片，置 0 表示这是最后一个分片。
- 片偏移：表示当前分片在原始数据包中的偏移位置，以 8 字节为单位。第一个分片的偏移为 0，后续分片依次递增。
- TTL（生存时间）：表示数据包在网络中的最大跳数（hops）。每经过一个路由器，TTL 减 1；减到 0 时，数据包被丢弃（防止无限循环）。
- **协议**：指示上层协议类型，例如 TCP（6）、UDP（17）、ICMP（1）等。告诉接收端如何处理数据部分（交给哪个协议栈）。
- 首部校验和：校验 IP 包头的完整性，是否在传输中出错。


- **源地址IP**：客户端输出的 IP 地址；
- **目标地址**：通过 DNS 域名解析得到的 Web 服务器 IP。

![](.\Basic\IP包头格式.webp)

**(2) IP 报文生成**

![](.\Basic\IP报文.webp)

### 6) 两点传输

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。 

**(1) MAC 包头格式** 

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。 

在 MAC 包头里需要**发送方 MAC 地址和接收方目标 MAC 地址**，用于两点之间的传输。 

一般在 TCP/IP 通信里，MAC 包头的协议类型只使用： 

- `0800`： IP 协议
- `0806`： ARP 协议

![](.\Basic\MAC包头格式.webp)

**(2) MAC 发送方和接收方如何确认?** 

**发送方**的 MAC 地址获取比较简单，MAC 地址是在网卡生产时写入到 **ROM** 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

**接收方**的 MAC 地址有点复杂，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。 

所以先得搞清楚应该把包发给谁，通过查**路由表**。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的 IP 地址就可以了。 

**(3) 既然知道要发给谁，按如何获取对方的 MAC 地址呢？** 

需要 **ARP 协议** 帮忙找到路由器中的 MAC 地址，ARP 协议 在以太网中以**广播**的形式，对以太网的设备喊出。

![](.\Basic\APR协议.webp)

**(4) 好像每次都要广播获取，这不是很麻烦吗？** 

在后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

在发包时：

1. 先查询 **ARP 缓存**，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。 
   - 查看 ARP 缓存内容：在 Linux 系统中，使用 `arp -a` 命令。 
2. 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 **ARP 广播查询**。 


**(5) MAC 报文生成**

![](.\Basic\MAC报文生成.webp)

### 7) 出口 — 网卡

网络包只是存放在内存中的一串**二进制数字信息**，没有办法直接发送给对方。需要将**数字信息转换为电信号**，才能在网线上传输，这才是真正的数据发送过程。 

负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**。 

网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。 

- **起始帧分界符**是一个用来表示包起始位置的标记
- **末尾的 FCS（帧校验序列）**用来检查包传输过程是否有损坏

最后网卡会将包转为电信号，通过网线发送出去。

![](.\Basic\网卡.webp)

### 8) 送别者 — 交换机

交换机的设计是将网络包**原样**转发到目的地。交换机工作在 **MAC 层**，也称为**二层网络设备**。 

**(1) 交换机的包接收操作** 

1. 首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。 

2. 然后通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

3. 计算机的网卡本身具有 MAC 地址，并通过核对**收到的包的接收方 MAC 地址**判断是不是发给自己的，如果不是发给自己的则丢弃；交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。**交换机的端口不具有 MAC 地址。** 

4. 将包存入缓冲区后，接下来需要查询一下这个**包的接收方 MAC 地址**是否已经在 **MAC 地址表**中有记录了。 

   **交换机的 MAC 地址表**主要包含两个信息： 

   - 一个是设备的 MAC 地址

   - 另一个是该设备连接在交换机的哪个端口上

5. **交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。**

**交换机中的端口**是指物理或逻辑的网络接口，用于连接设备或划分VLAN，这些端口工作在数据链路层（第2层），主要处理MAC地址和帧的转发。

**TCP协议中的端口**是传输层（第4层）的逻辑标识，用于区分同一主机上不同应用程序或服务的通信。

![](.\Basic\交换机.webp)

**(2) 当 MAC 地址表找不到指定的 MAC 地址会怎么样？** 

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。

这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。

> 有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？” 
>
> 发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

### 9) 出境大门 — 路由器

**(1) 路由器与交换机的区别**

网络包经过交换机之后，到达**路由器**，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过**查表判断包转发的目标**。 

在具体的操作过程上，路由器和交换机是有区别的。 

- **路由器**是基于 **IP** 设计的，俗称**三层网络设备**，路由器的各个端口都具有 **MAC 地址和 IP 地址**。
- **交换机**是基于**以太网**设计的，俗称**二层网络设备**，交换机的端口不具有 MAC 地址。 

**(2) 路由器基本原理**

路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

**(3) 路由器的包接收操作**

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

**(4) 查询路由表确定输出端口**

完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

MAC 头部的作用就是**将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询**路由表**判断转发目标。

![](.\Basic\路由转发包.webp)

**(5) 路由器的发送操作**

接下来就会进入**包的发送操作**。 

1. 首先，需要根据**路由表的网关列**判断对方的地址。

   - 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。

   - 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。

2. 知道对方的 IP 地址之后，接下来**通过 `ARP` 协议根据 IP 地址查询 MAC 地址**，并将查询的结果作为**接收方 MAC 地址**。

   路由器也有 `ARP` 缓存，因此首先会在 `ARP` 缓存中查询，如果找不到则发送 `ARP` 查询请求。 

3. 接下来是**发送方 MAC 地址字段**，这里填写**输出端口的 MAC 地址**。还有一个以太类型字段，填写 `0800 `（十六进制）表示 IP 协议。

4. 网络包完成后，接下来会将其转换成电信号并通过端口发送出去。

5. 发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

6. 接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。


在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

### 10) 互相扒皮 — 服务器与客户端

1. 数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。
2. 接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。
3. 于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。
4. TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。 于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。
5. 服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。
6. **HTTP 响应报文**也需要穿上 TCP、IP、MAC 头部，不过这次是**源地址是服务器 IP 地址，目的地址是客户端 IP 地址**。
7. 从网卡出去，交由交换机转发到路由器，路由器就把响应数据包发到了下一个路由器。
8. 最后跳到了客户端的城门把守的**路由器**，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。
9. 客户端收到了服务器的响应数据包后，把收到的数据包的皮**扒剩 HTTP 响应报文后，交给浏览器去渲染页面**。
10. **客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。**

![](.\Basic\服务器与客户端.webp)

