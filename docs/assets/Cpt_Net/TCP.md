# TCP三次握手和四次挥手

## TCP基本认识

### TCP头部格式

- 源端口号：标识发送方的应用程序或服务，用于表示数据是从哪个进程发出的。
- 目标端口号：标识接收方的应用程序或服务，表示数据要发送到哪个进程。

- 序列号：识发送的数据字节流的顺序，确保数据按序到达。在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决**网络包乱序**问题。 
- 确认应答号：确认接收到的数据，通知发送方哪些数据已正确接收。指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决**丢包**的问题。
- 控制位：
  - ACK（*Acknowledgment*，确认位）：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
  - RST(*Reset*，重置位)：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
  - SYN(*Synchronize*，同步位)：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
  - FIN(*Finish*，结束位)：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。
  - URG(*Urgent*，紧急位)：该位为1时，表示数据段中包含紧急数据，紧急指针字段有效。
  - PSH(*Push*，推送位)：该位为1时，建议发送方尽快将数据推送给接收方的应用层，而不是等待缓冲区填满。接收方收到 PSH=1 的报文后，也会尽快将数据交给应用层，而不是等待更多数据。常用于实时应用（如聊天程序），减少延迟。

- 首部长度：表示 TCP 头部的长度，帮助接收方确定数据从哪里开始。

- 保留位：为了未来扩展使用，目前必须置为 0。它的存在是为了协议升级时可能新增功能，但现在没有实际作用。

- 窗口大小：用于**流量控制**，表示接收方当前能够接收的数据量（单位是字节）。它告诉发送方接收方的缓冲区还有多少空间可用，避免发送方发送过快导致接收方处理不过来。

- 紧急指针：只有在 URG 标志位被置为 1 时才有效。它指出 **TCP 数据段中紧急数据的结束位置（偏移量）**，相对于序列号的偏移。

- 校验和：用于错误检测，覆盖 TCP 头部、数据以及伪头部（包括 IP 头部的一些字段，如源IP和目标IP）。发送方计算校验和，接收方验证，确保数据在传输中未被损坏。如果校验和不匹配，数据会被丢弃。

- 选项（长度可变）

  - MSS（最大段大小）：通知对方本端能接收的最大数据段长度。


  - 窗口缩放：提高窗口大小，适应高速网络。
  - 时间戳：用于计算 **RTT（往返时间）**和防止序列号回绕问题。

![](.\TCP\TCP头部格式.webp)

### 为什么需要 TCP 协议？ TCP 工作在哪一层？

TCP 是一个工作在**传输层**的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

![](.\TCP\TCP+IP和OSI模型.webp)

### 什么是 TCP ？

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。 

- 面向连接：通过三次握手和四次挥手建立和结束连接，连接只能一对一，不能一对多(UDP 协议)。
- 可靠的：保证数据不丢失、不重复、不乱序，且数据内容无差错，即使网络环境不稳定（如丢包、延迟、乱序）。
  - 序列号和确认机制
  - 校验和
    - TCP头部包含校验和字段，覆盖头部、数据和伪头部（包括IP地址等）。
    - 发送方计算校验和，接收方验证。如果校验和不匹配，数据被丢弃，触发重传。
  - 流量控制（滑动窗口）：接收方通过窗口大小字段告知发送方自己的接收能力，避免发送过快导致数据丢失。
  - 拥塞控制：通过慢启动、拥塞避免、快重传和快恢复等机制，动态调整发送速率，避免网络过载导致丢包。
- 字节流：
  - 将**应用层的数据**看作一个连续的字节流，而不是离散的消息或数据包。TCP负责将字节流分割成**段（*Segment*）**发送，接收方不知道**发送方的消息边界**，数据以**字节流**形式交付给应用层。
  -  TCP 报文是**「有序的」**，处理完前一个才能处理后一个，不会处理重复报文。

### 什么是 TCP 连接？

用于保证**可靠性和流量控制维护的某些状态信息**，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。 

建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。 

- Socket(套接字)：由 IP 地址和端口号组成，一个TCP连接由两个Socket唯一标识，即**四元组**。
- 序列号(*sequence numbers*)：用来解决乱序问题等
- 窗口大小(*window sizes*)：
  - 用来做流量控制，发送方根据接收方的窗口大小调整发送速率，避免发送过快导致接收方缓冲区溢出。
  - TCP使用滑动窗口机制，发送方可以连续发送窗口大小内的数据，而不必等待确认，提高传输效率。

### 如何唯一确定一个 TCP 连接呢？

- 源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议**发送报文给对方主机**。
- 源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该**把报文发给哪个进程**。

![](.\TCP\TCP四元组.webp)

### UDP 和 TCP 有什么区别呢？分别的应用场景是？

- 目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。
- 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
- 校验和：为了提供可靠的 UDP 首部和数据而设计，**防止收到在网络传输中受损的 UDP 包**。

![](.\TCP\UDP头部格式.webp)

**TCP 和 UDP 区别：**

1. 连接
   - TCP 是面向连接的传输层协议，传输数据前先要建立连接。
   - UDP 是不需要连接，即刻传输数据。
2. 服务对象
   - TCP 是一对一的两点服务，即一条连接只有两个端点。
   - UDP 支持一对一、一对多、多对多的交互通信。
3. 可靠性
   - TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
   - UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。
4. 拥塞控制、流量控制
   - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
   - UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 首部开销
   - TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
   - UDP 首部只有 8 个字节，并且是固定不变的，开销较小。 
6. 传输方式
   - TCP 是流式传输，没有边界，但保证顺序和可靠。
   - UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。 
7. 分片不同
   - TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
   - UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

**TCP 和 UDP 应用场景：**

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP 文件传输
- HTTP / HTTPS

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP 等
- 视频、音频等多媒体通信
-  广播通信

## TCP 连接建立

### TCP 三次握手过程是怎样的？

1. 都处于 `CLOSE` 状态，服务端先是 `LISTEN` 状态监听端口
2. ①客户端随机初始化序列号 `client_isn` 并置于 TCP 首部序列号中，SYN (*客户端 向 服务端*)标记为 1 ，表示希望建立连接。②随后将 SYN 报文（**不包含应用层数据**）发送给客户端，表示向服务端发起连接。③客户端发完 SYN 后，处于 `SYN_SENT` 状态。【第一个报文】
3. ①服务端收到 SYN 报文，也会初始化自己的序列号 `service_isn`，填入 TCP 首部的序号列中。②确认应答号填入 `client_isn + 1`，SYN (*服务端 向 客户端建立连接*)和 ACK 标志为1。③把报文(**不含应用层数据**)发送给客户端，服务端处于`SYN_RCVD` 状态。【第二个报文】
4. ①客户端收到服务端报文，还需要返回应答报文，报文首部 ACK 标志为1。②确认应答号字段填入 `service_isn + 1`，将报文（**可以携带客户到服务端的数据**）返给服务端。③客户端处于 `ESTABLISHE` 状态。【第三个报文】
5. 服务端接收到应答报文，也进入 `ESTABLISHE` 状态。

![](.\TCP\TCP三次握手.drawio.webp)

**模糊点梳理**

1. 随机化序列号（ISN，*Initial Sequence Number*）
2. 初始化序列号 `Seq Num = client_isn`，TCP将数据分成多个报文段（segment）发送，每个报文段都有一个序列号，用于标识数据在整个流中的位置。客户端初始化一个随机序列号 `client_isn` 作为数据的起点，服务端接收后知道从哪里开始计数。
3. 服务端初始化序列号 `Seq Num = service_isn`，TCP是全双工协议，客户端和服务端都可以发送数据，服务端初始化自己的序列号 `service_isn`，作为它发送数据的起点。
4. 确认应答号填入 `client_isn + 1 ` 表示接收方期望接收的**下一个字节**的序列号。确认应答号字段填入 `service_isn + 1` 同理。

### 为什么是三次握手？不是两次、四次？

**①防止历史连接并初始化连接**

1. 比如网络堵塞的情况下，在重新连网后，旧报文比新报文先到达，客户端的确认应答号通过比较上下文，确认期望处理的报文不是旧报文，所以可以发送 RST 报文。
2. 服务端收到 RST 报文后，就可以断开旧报文的连接。

![](.\TCP\TCP三次握手避免历史连接.webp)

而两次连接，服务端没有中间状态给客户端处理来处理。服务端接收到 SYN 报文后，直接进入 `ESTABLISHED` 状态，返回的 ACK 得知不是自己想要的，只能发送 RST 报文，断开连接。

![](.\TCP\TCP两次握手不能避免历史连接.webp)

**②同步双方初始序列号**

两次握手只能保证一方的序列号被接受。

![](.\TCP\四次握手和三次握手.webp)

**③避免资源浪费**

两次握手只能保证一方收到初始序列号，服务端可能不知道客户端是否收到自己的 ACK 报文，只能创建多次连接，连接冗余。

![](.\TCP\两次握手.webp)

### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）
-  为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收

### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

- MTU：一个网络包的最大长度
- MSS： 一个网络包所能容纳的 TCP 数据的最大长度

IP 层超过 MTU 数据大小，会分层，会导致 TCP 首部数据缺失，无法形成完整的 TCP 报文，接收方不会响应 ACK 给发送方，发送方迟迟没收到，会导致超时重传。

![](.\TCP\网络包.webp)

### 第一次握手丢失了，会发生什么？

重传的SYN报文都会一样，重传的次数取决于 `tcp_syn_retries`

🧐我的疑问：客户端生成的初始化序列号是随机生成的，为什么不生成一个新的，而是使用相同的 `client_isn`？

只要是同一次的尝试，相同的连接，重传的 SYN 报文保持一致，必须使用相同的初始序列号 `client_isn`。

🗒️重传的 SYN 报文 和 历史连接的 SYN 报文

- 客户端重传的 SYN 是为了同一个连接，序列号 `client_isn` 保持不变。
- 历史连接的 SYN 报文来自之前的 TCP 连接（已关闭），序列号是旧连接的 `old_isn`，与当前连接的`client_isn` 不同。

![](.\TCP\第1次握手丢失.png)

### 第二次握手丢失了，会发生什么？

- ACK 确认报文丢失，客户端会触发超时重传机制，重传 SYN 报文。
  - 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries` 内核参数决定。
- 服务端收不到第三次握手，服务端会触发超时重传机制，重传 SYN-ACK 报文。
  - 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。

![](.\TCP\第2次握手丢失.webp)

### 第三次握手丢失了，会发生什么？

ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文【服务端重传 SYN - ACK 报文】。

![](.\TCP\第三次握手丢失.drawio.webp)

### 什么是 SYN 攻击？如何避免 SYN 攻击？

TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务。

![](.\TCP\SYN攻击.webp)

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列
- 全连接队列，也称 accept 队列

正常流程：

1. 当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；
2. 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
3. 服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；
4. 应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接对象。

![](.\TCP\SYN正常流程.webp)

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。

避免 SYN 攻击方式，可以有以下四种方法：

1. 调大 `netdev_max_backlog`；
2. 增大 TCP 半连接队列；
3. 开启 `tcp_syncookies`；
4. 减少 SYN+ACK 重传次数

**(1) 调大 `netdev_max_backlog`**

当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：

```sh
net.core.netdev_max_backlog = 10000
```

**(2) 增大 TCP 半连接队列**

1. 增大 `net.ipv4.tcp_max_syn_backlog`
2. 增大 `listen()` 函数中的 `backlog`
3. 增大 `net.core.somaxconn`

**(3) 开启 `net.ipv4.tcp_syncookies`**

开启 `syncookies` 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。

![](.\TCP\net.ipv4.tcp_syncookies.png)

具体过程：

1. 当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 cookie 值；
2. 将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；
3. 服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。
4. 最后应用程序通过调用 accpet() 接口，从「 Accept 队列」取出的连接。

当开启了 `tcp_syncookies` 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。 

`net.ipv4.tcp_syncookies` 参数主要有以下三个值：

- 0 值，表示关闭该功能；
- 1 值，表示仅当 SYN 半连接队列放不下时，再启用它；在应对 SYN 攻击时，只需要设置为 1 即可。
- 2 值，表示无条件开启功能。

```sh
$ echo 1 > /proc/sys/net/ipv4/tcp_syncookies
```

**(4) 减少 SYN+ACK 重传次数**

当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。

那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。

SYN-ACK 报文的最大重传次数由 `tcp_synack_retries` 内核参数决定（默认值是 5 次），比如将 `tcp_synack_retries` 减少到 2 次：

```sh
$ echo 2 > /proc/sys/net/ipv4/tcp_synack_retries
```

## TCP 连接断开

### TCP 四次挥手过程是怎样的？

1. 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 1 的报文，也即 **`FIN` 报文**，之后客户端进入 `FIN_WAIT_1` 状态。
2. 服务端收到该报文后，就向客户端发送 **`ACK` 应答报文**，接着服务端进入 `CLOSE_WAIT` 状态。
3. 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
4. 等待服务端处理完数据后，也向客户端发送 **`FIN` 报文**，之后服务端进入 `LAST_ACK` 状态。
5. 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态。
6. 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
7. 客户端在经过 2MSL 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

每个方向都需要一个 `FIN` 和一个 `ACK`，因此通常被称为四次挥手。

主动关闭连接的，才有 `TIME_WAIT` 状态。

> 2MSL（两倍的最大报文段生存时间，*Maximum Segment Lifetime*）
>
> 确保有足够的时间接收到服务端可能重传的 FIN 报文，并重新发送 ACK。
>
> 如果客户端发送 ACK 后立即关闭（不等待 2MSL），一旦 ACK 丢失，服务端将无法正常关闭连接，导致服务端可能长时间停留在 LAST_ACK 状态。

![](.\TCP\四次挥手.webp)

### 为什么挥手需要四次？

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

从上面过程可知，**服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送**，因此是需要四次挥手。

但是在特定情况下，四次挥手是可以变成三次挥手的。

### 第一次挥手丢失了，会发生什么？

第一次挥手失败，客户端没有收到服务端的 **ACK 报文**，会触发超时重传机制，**重传 FIN 报文**，重发次数由 `tcp_orphan_retries` 参数控制。

重传 FIN 报文 超过参数控制次数，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 `close` 状态。

![](.\TCP\第一次挥手丢失.webp)

### 第二次挥手丢失了，会发生什么？

ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。

![](.\TCP\第二次挥手丢失.webp)



在应用层，程序员通过调用 `close` 或 `shutdown` 函数来关闭 TCP 连接。

`close` 函数关闭 Socket 文件描述符，释放资源。

`shutdown` 允许半关闭（只关闭写端），让客户端在发送 `FIN` 后仍能接收数据，避免数据丢失。

- `shutdown(SHUT_WR)`：关闭写通道，发起 `FIN`，但仍可读取数据。
- `shutdown(SHUT_RD)`：关闭读通道。
- `shutdown(SHUT_RDWR)`：关闭读写通道，相当于 `close`。

当客户端收到第二次挥手，也就是收到服务端发送的 `ACK` 报文后，客户端就会处于 `FIN_WAIT2` 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 `FIN` 报文。

调用 `close` 后，`Socket` 被完全关闭，客户端无法再发送或接收数据，客户端在 `FIN-WAIT-2` 状态下无法处理任何数据（包括接收服务器的 `FIN`）。

如果服务器迟迟不发送 `FIN`（例如服务器程序未调用 `close` 或 `shutdown`，或网络问题），客户端不能无限等待。所以 `FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。

这意味着对于调用 `close` 关闭的连接，如果在 60 秒后还没有收到 `FIN` 报文，客户端（主动关闭方）的连接就会直接关闭。

![](.\TCP\fin_wait_2.drawio.webp)

如果使用 `shutdown(SHUT_WR)`，只关闭写方向（发送`FIN`，第一次挥手），但读方向（接收数据）仍保持开放。

如果服务器迟迟不发送 `FIN`，客户端会一直停留在 `FIN-WAIT-2` 状态，等待服务器的 `FIN`。对于`shutdown(SHUT_WR)` 关闭的连接，`tcp_fin_timeout` 无法控制 `FIN-WAIT-2` 状态的持续时间。

原因：`tcp_fin_timeout` 通常适用于 `close` 完全关闭 `Socket` 的情况，而 `shutdown(SHUT_WR)` 只关闭了写方向，`Socket` 仍部分活跃（读方向开放），操作系统不会强制超时关闭。

因此，客户端可能会无限期停留在 `FIN-WAIT-2` 状态，直到收到服务器的 `FIN` 或出现其他异常（例如网络断开）。

如果主动关闭方使用 `shutdown` 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。

此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 `FIN_WAIT2` 状态（`tcp_fin_timeout` 无法控制 `shutdown` 关闭的连接）。

![](.\TCP\fin_wait_2死等.drawio.webp)

### 第三次挥手丢失了，会发生什么？

当服务端（被动关闭方）收到客户端（主动关闭方）的 `FIN` 报文后，内核会自动回复 `ACK`，同时连接处于 `CLOSE_WAIT` 状态，它表示等待应用进程调用 **`close` 函数**关闭连接。

此时，内核是没有权利替代进程关闭连接，必须由进程**主动调用 `close` 函数**来触发服务端发送 `FIN` 报文。

服务端处于 `CLOSE_WAIT` 状态时，调用了 `close` 函数，内核就会发出 `FIN` 报文，同时连接进入 `LAST_ACK` 状态，等待客户端返回 `ACK` 来确认连接关闭。

如果迟迟收不到这个 `ACK`，**服务端就会重发 `FIN` 报文**，重发次数仍然由 `tcp_orphan_retries` 参数控制，这与客户端重发 `FIN` 报文的重传次数控制方式是一样的。

![](.\TCP\第三次挥手丢失.drawio.webp)

### 第四次挥手丢失了，会发生什么？

在 Linux 系统，`TIME_WAIT` 状态会持续 `2MSL` 后才会进入关闭状态。

服务端（被动关闭方）没有收到 `ACK` 报文前，还是处于 `LAST_ACK` 状态。

如果第四次挥手的 `ACK` 报文没有到达服务端，服务端就会重发 `FIN` 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。

![](.\TCP\第四次挥手丢失drawio.drawio.webp)

### 为什么 TIME_WAIT 等待的时间是 2MSL？

`MSL`（*Maximum Segment Lifetime*，最大报文生存时间）超过这个时间报文将被丢弃。因为 TCP 报文基于是 **IP 协议**的，而 IP 头中有一个 **`TTL ` 字段**，是 IP 数据报可以经过的**最大路由数**，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： 

MSL 的单位是**时间**，

而 TTL 是**经过路由跳数**。

所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡**。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

`TIME_WAIT` 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

> 比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

2MSL时长 这其实是相当于**至少允许报文丢失一次**。

> 比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。 

2MSL 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 `TIME-WAIT` 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。

在 Linux 系统里 2MSL 默认是 60 秒。Linux 系统停留在 `TIME_WAIT` 的时间为固定的 60 秒。

其定义在 Linux 内核代码里的名称为 `TCP_TIMEWAIT_LEN`：

```c
#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT state, about 60 seconds */
```

如果要修改 `TIME_WAIT` 的时间长度，只能修改 Linux 内核代码里 `TCP_TIMEWAIT_LEN` 的值，并重新编译 Linux 内核。

### 为什么需要 TIME_WAIT 状态？

主动发起关闭连接的一方，才会有 `TIME-WAIT` 状态。

需要 `TIME-WAIT` 状态，主要是两个原因：

1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
2. 保证「被动关闭连接」的一方，能被正确的关闭。

**(1) 防止历史连接中的数据，被后面相同四元组的连接错误的接收**

序列号（SEQ）：是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后**确认、丢失后重传以及在接收端保证不会乱序**。序列号是一个 **32 位的无符号数，因此在到达 4G 之后再循环回到 0**。

初始序列号（ISN）：在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于**时钟**生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 **32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时**。

**序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据。**

假设 `TIME-WAIT` 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？

为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 `TIME_WAIT` 状态，状态会持续 `2MSL` 时长，**这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的**。

![](.\TCP\无TIME_WAIT原因1.webp)

**(2) 保证「被动关闭连接」的一方，能被正确的关闭**

`TIME-WAIT` 作用是**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭**。

如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。

假设客户端没有 `TIME_WAIT` 状态，而是在发完最后一次回 ACK 报文就直接进入 `CLOSE` 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 **RST 报文**。

![](.\TCP\无TIME_WAIT原因2.webp)

服务端收到这个 RST 并将其解释为一个错误（*Connection reset by peer*），这对于一个可靠的协议来说不是一个优雅的终止方式。

为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。

![](.\TCP\TIME-WAIT连接正常关闭.drawio.webp)

### TIME_WAIT 过多有什么危害？

1. 占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
2. 占用端口资源，端口资源也是有限的，一般可以开启的端口为 32768～61000，也可以通过 `net.ipv4.ip_local_port_range` 参数指定范围。

**如果客户端（主动发起关闭连接方）的 `TIME_WAIT` 状态过多**，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。

客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务端建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。

不过，即使是在这种场景下，只要连接的是不同的服务端，端口是可以重复使用的，所以客户端还是可以向其他服务端发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。

**如果服务端（主动发起关闭连接方）的 `TIME_WAIT` 状态过多**，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。

### 如何优化 TIME_WAIT？

1. 打开 `net.ipv4.tcp_tw_reuse` 和 `net.ipv4.tcp_timestamps` 选项；
2. `net.ipv4.tcp_max_tw_buckets`；
3. 程序中使用 `SO_LINGER` ，应用强制使用 RST 关闭。

### 服务器出现大量 TIME_WAIT 状态的原因有哪些？

`TIME_WAIT` 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 `TIME_WAIT` 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。

什么场景下服务端会主动断开连接呢？

1. HTTP 没有使用长连接
2. HTTP 长连接超时
3. HTTP 长连接的请求数量达到上限







